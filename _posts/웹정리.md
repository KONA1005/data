# HTML
HyperText Markup Language
웹에서 정보를 전달하려고
마크업 : 정보의 형식과 구조
만드는법 : 확장자를 .html
    파일 제일위에 !<DOCTYPE html>로 시작

### 태그들
<a> : anchor. href 속성을 통해서 다른 html파일로 이동할 수 있다.
<head> : 메타데이터
<body> : 보여지는 본문
<div> : 무색무취의 한줄 다 차지
<span> : 콘텐츠영역만큼만 차지
<table> : 표
<p> : paragraph. 문단
<img> : image. 사진이나 그림
<h1~h6> : highlight, headline. 중요한 제목


<ul> : unodered list. 순서가 없는 리스트
<ol> : ordered list. 순서가 있는 리스트
<li> : list item. 리스트의 아이템
<form> : 제출할 형태
<input> : 제출할 인풋 내용
<button> : 버튼

<style> : </style>을 만날때까지 html이 아닌 css문법으로 해석
<script> : </script>를 만날때까지 html이 아닌 script문법으로 해석
<link> : 다른문서와 링크되어 그 문서의 내용을 이 문서로 복붙
<nav> : navigation.

- Sementic : 시멘틱. 의미상의. html 자체가 본질이 정보지만 html5에서 더욱더 그 의미로서의 정보가 강조됨.    의미가 강조된 태그들이 생겨났다.
nav, main, aside, footer 이런 태그들..
<b> 와 <strong> 의 차이
bold는 시각적으로만 글자를 두껍게 하는거고
strong은 의미상으로 중요한 글자임을 나타내는 것. 시각적으로 두껍게하는건 저절로 따라오는 개념.

- 왜 시멘틱하게 HTML을 만들어야 하냐?
: 유지보수의 용이성은 둘째치고 SEO(검색 엔진 최적화)
  검색엔진 봇들이 돌아다니면서 이 페이지에는 어떤 정보가 있는지를 자기들 데이터베이스에 가져가는데 SEO가 잘 되지 않으면 상단 노출이 안된다. -> 비지니스 망한다.
  사용자 편의성 -> 시각장애인, 색맹 등 정상적으로 웹페이지를 볼 수 없는 환경에서 의미상 중요도를 읽어서 내용을 전달해주는데. 시멘틱하지 않으면 무엇이 중요한 정보인지 판단할 수 없다.

- HTML의 요소는 중첩가능하고 어떤 태그의 속성이 있는지 없는지, 닫히는 태그가 있어야 하는지 없는지는 상식적으로 생각하면 된다.
  예) <img> 얘는 닫히는거 필요없어
      이미지의 원천을 지정해주면 됨. src속성 <img src="이미지경로">

      <p> 태그는 닫히는거 필요해
      문단이라는것은 어디부터 어디까지를 하나의 문단으로 결정할것이지 있어야 되기 때문에 닫히는 태그가 필요하다.


# CSS
- Cashading Style Sheet : 물처럼 흐르는 스타일 표
- 왜 써? : 문서(요소)에 디자인적 서식을 지정하기 위해서 -> 디자인을 꾸밀려고
- 탄생배경 : 원래는 HTML이라는 언어만 있었다. 근데 디자인을 태그나 속성으로 하다보니 정보라는   HTML에 본질이 흐릿해지기 시작했다. -> 디자인만 따로 다루는 언어를 새로 만드는게 좋겠다~해서
- 사용하는 법 
: 1. 스타일을 지정하려는 태그안에다가 속성값을 넣는 '인라인'
  2. <style> 태그안에 별도로 뻬기 '내부'
  3. .css 파일로 별도로 빼기 '외부'

- 문법 : 
  선택자{
    속성1 : 값;
    속성2 : 값;
  }

- 어떻게 선택하는가?
  -  태그 : 그냥이름
  -  클래스 : .이름
  -  id : #이름
  -  자식태그 : 이름1>이름2. 이름1의 자식인 이름2. 내가 낳은애
  -  자손태그 : 이름1 이름2. 이름1의 자손인 이름2. 내 자식의 자식의 자식의 자식도 자손. 자식의 자식도 자손
  -  여러개 : , 이름1,이름2. 이름1,이름2 둘다
  
- 중요한 속성
  : color, background-color, width, height, padding, margin
    position, display, border
- float : 둥둥 떠다닌다. 이미지를 글자위에 둥둥 떠다니게 배치하기 위해 
          만들어진 문법
- 박스모델 : 모든 요소는 박스모델이다. 동그랗게 보이던, 선으로 보이던 모두가 박스모델이다.
            개발자모드로 확인하면 컨텐츠 영역은 파란색
            border를 기준으로 안쪽은 padding, 바깥쪽은 margin
- position : 위치.
             선택자가 어디에 어떤 기준으로 위치할 것인가를 결정.
             static : 디폴트. 웹의 기본적인 흐름에 따른다. 위에서 아래로 / 왼-오
             relative : 상대적인. static을 기준으로 해서 offset만큼 이동한다.
                offset : (top, right, bottom, left)은 웹페이지상에서 해당요소를 해당기준에서 얼마나 떨어져야 하는지를 결정한다.
                예) top : 30px;  // 첫번째 주소를 기준으로 top에서부터 30px을 더한값이 두번째 주소가 된다.
             absolute : 절대적인. static이 아닌 부모요소를 기준으로 하여 offset만큼 이동
                        그런 부모가 없다면 body를 기준으로 한다.
                        포토샵의 레이어같이 새로운 층으로 해석된다.
             sticky : 스크롤을 하다가 없어지지 않고 스티커같이 해당위치에 고정된다. 
                      스크롤을 하다가 그 위치
             fixed : 처음 지정한 위치에 고정된다. 스크롤과 상관 없음. 항상 그 위치
- display : 박스모델에 인라인과 블록으로 나뉜다.
  inline : 자기 영역만큼만 차지. width, height 속성 없음
  block : 한줄 다 차지
  inline-block : 자기영역만큼만 차지하는데 width, height 속성 줄 수 있음

- flex : 가로축과 주축의 개념. 컨테이너와 아이템의 개념
  
- bootstrap : 트위터에서 만든 오픈소스 css프레임워크
    적용방법
        1. 부트스트랩 소스 다운
        2. 어떤 디자인 쓸건지 찾기
        3. 해당 클래스로 클래스명 변경 

- 단위
  절대단위 : px,
  상대단위 : em, rem, %, vh, vw

- 미디어쿼리
  mediaQuery
  반응형페이지 : 반응형이라는것은 하드웨어의 해상도에 반응해서 디자인이 바뀌는 것.

# JS
웹 브라우저에서 유일하게 동작하는 프로그래밍 언어.
하지만 반대로 자바스크립트는 유일하게 웹브라우저에서 동작하는가 ? -> X  NodeJS 환경에서 가능

브라우저의 역사.
  MS의 익스플로어가 망쳐놓은 역사
  춘추전국시대에 등장한 Jquery
  구글의 크롬이 평정한 역사.

자바스크립트의 3요소
: DOM, BOM, CORE엔진

- 데이터타입
: **자바스크립트는 dynamic Typed 언어이다. 데이터타입이 선언시 결정되는 것이 아니라 값에 의해 결정된다**
  원시형 데이터타입 : boolean, null, undefined, number, string
  이 자료형 외에는 모두 참조형 데이터타입
  데이터타입을 이렇게 쪼개놓은 이유는? -> 비싼 자원인 메모리를 효율적으로 쓰기 위해서.

- 변수
: variable
  왜 변수 쓰냐?
    1. 값에 이름을 붙여줘서 무슨의도인지 파악하게 함
    2. 값을 직접 사용하지 않고 그릇에 담아서 유지보수 편하게 하려고
        ( 하나의 값을 변경시키면 해당변수를 쓰는 모든곳이 일괄적으로 변경됨)
  변수 선언은 ?
    var 이름 = 값;
    let 이름 = 값;
    const 이름 = 값;    -> 상수선언. 값을 초기화 이후에 바꿀 수 없다.
  var 와 let의 차이? 언제 뭐를 써야하냐?
    var는 쓰면 안됨. 문제가 많아서. 개발자의 상식에 어긋나는 일이 많이 일어난다. 선언하지 않고 사용할 수 있다. 재선언이 가능하다.
    호이스팅이 된다. 블록의 범위를 무시한다.

    - (**중요**) var키워드로 선언된 변수는 [오로지 함수]의 코드 블록만을 지역 스코프로 인정한다. 즉, 함수안에서는 지역스코프로 먹히고 함수안이 아닌곳에서는 전역변수 취급한다는 말이다.

    - 반면에 let, const로 선언한 변수는 모든 코드블록을 지역스코프로 인정하는 블록레벨 스코프를 따른다.

- 배열
  what : 같은 자료형(자바스크립트에서는 데이터타입이 달라도 됨) 여러개를 하나로 묶은것
  why  : 높은 응집도를 위해서. 같은 목적을 가지고 있는 애들끼리 묶어서 간단하게 하나의 변수로 처리하기 위해서.
  how  : 
   - 배열선언
     let 배열명 = [];

- 연산자 
  what : 연산을 수행하는 기호. 연산은 식을 계산하여 결과를 얻는 과정. 사칙연산(+,-,*,/), %(나머지), 증감(++, --), 제곱(**), 논리(&&, ||, !=, ==)
  why  : 우리가 무엇을 어떻게 부를지 단어에 대한 약속을 한것이 언어이듯이 수학의 연산을 어떻게 할 것인지에 대한 **약속**을 한것이 연산자
  how  : what만 알면 상식적으로 쓰면 된다.
         ++이라는 연산자를 쓰고싶어 -> 피연산자가 몇개 있어야 해?
         2개의 피연산자가 필요한 연산자를 이항연산자 이라고 한다.
         1개의 피연산자가 필요한 연산자를 단항연산자 이라고 한다.
         전위연산자 -> 변수를 사용하기 전에 연산을 먼저
         후위연산자 -> 변수를 사용하고 연산을 나중에
    ex) let a = 4;
        let b = 10;
        let result = ++a + b++ - (++a);    5 + 10 - (6) = 9
        let result2 = a++ + ++b;           6 + 12 = 18
        console.log(result);
        console.log(result2);

- 조건문
  what : 조건에 따라 컴퓨터가 실행할 문장이 달라지는 것 
  why  : 조건에 따라 다른 할일을 시키기 위해서
  how  : 
        if(조건){
            조건을 만족할때 실행할 본문;
        }else if(그 외의 조건){
            조건2를 만족할때 실행할 본문;
        }else if(그 외의 조건){
            조건2를 만족할때 실행할 본문;
        }else{
            그외에 아무것도 만족하지 않았을때 실행할 본문;
        }

        // 표현식은 boolean으로 판단가능해야한다.
        // else if와 else는 가장 가까운 if와 연결되어 있다.
        // if안에 if 중첩 가능
        // if, if, if를 쓰면 위의 if를 만족하더라도 모든 if를 검사하기 때문에 if를 여러개쓸지, if else를 쓸지를 잘 판단해야 한다.

    - 간단한 조건문은 삼항연산자
        (조건표현식)? 참일 때 리턴할 것 : 거짓일때 리턴할 것;
    - 일괄적인 조건문은 switch문을 쓰는것이 좋다.
        switch(조건){
            case 조건1:
                 조건1을 만족할때 실행할 문장들;
                 break;
            case 조건2:
                 조건2를 만족할때 실행할 문장들;
                 break;
            case 조건3:
                 조건3을 만족할때 실행할 문장들;
                 break;
            default;
                 아무것도 만족안할때 실행할 문장들;
        }
           // break는 조건문이나 반복문을 끝내는 역할. 안쓰면 다음 case를 실행한다.
           // continue를 만나면 이번 검사만 끝내고 다음 검사로 넘어감

- 반복문
  what : 특정조건을 만족하는 한 블록의 문장을 반복해서 실행
  why  : 귀찮으니까 노가다 안할라고
  how  :
      - while   // if가 while로 바뀐것과 같다.
          while (조건){
                실행문;
          }
        - do while
          조건검사를 하기 전에 실행1번을 먼저 하는 문법

      - for
          for(초기화; 조건; 스탭;){
              조건을 만족할때 반복할 본문
          }    
          for(let i=1; i>0; i++){
              console.log(i);
          }
        - 향상된 for    // 반복문을 돌 수 있는 객체에 담긴 모든 요소에 대해 실행
            for(데이터타입 요소이름 in/of 이터레이터){
                인자마다 실행할 본문
            }
            in은 키를 리턴, of는 값을 리턴

- 함수
  what : 특정 목적을 가지고 특정 프로세스를 하는 코드들의 묶음
         input을 주면 output을 준다.
  why  : 높은 응집도. 같은 목적을 가진 코드기리 묶음처리해서 코드의 양을 줄이고 유지보수를 쉽게 한다.
  how  : 
    - 선언식 : 내가 알고있는 방법.
              function 함수명(인풋1, 인풋2){
                    본문;
                    return 리턴값;
              }
              // JS는 다이나믹타입인걸 유의. 
              // 인풋에 데이터타입이 없음. 리턴도 없을 수 있다.
              // input도 없을 수 있다.
    - 표현식 : 자바스크립트의 이상한 방법. 자바스크립트는 함수가 1급객체이기 때문에 가능한 방법. 
              이름이 없는 익명함수를 선언하고, 이름이 있는 변수에 할당할 수 있다.
              let 이름 = function (인풋){본문};

- 객체
- 이벤트
- 콜백함수
- AJAX
- 